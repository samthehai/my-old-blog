<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="icon" href="/favicon.ico"/><meta name="description" content="My personal blog"/><meta property="og:image" content="https://og-image.now.sh/Hai%20Sam&#x27;s%20Blog.png?theme=light&amp;md=0&amp;fontSize=75px&amp;images=https%3A%2F%2Fassets.zeit.co%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><meta name="og:title" content="Hai Sam&#x27;s Blog"/><meta name="twitter:card" content="summary_large_image"/><title>Cấu trúc dữ liệu trong Go: Interfaces</title><link rel="preload" href="/_next/static/css/a7b17ee9c118794ec99f.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a7b17ee9c118794ec99f.css" data-n-g=""/><link rel="preload" href="/_next/static/css/ef8b6818b7474fff8094.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ef8b6818b7474fff8094.css" data-n-p=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-d283b4ab393ebd284c3e.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9ec1f7868b3e9d138cdd.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.e3c12cb767780eaa6561.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-ded95831299dc0ee3969.js" as="script"/><link rel="preload" href="/_next/static/chunks/7989c093b81d86ddb0abfb342d5bc2e84730435d.a106123a322eba1d4442.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/posts/%5Bid%5D-f3a8cc6c89a99a8d726d.js" as="script"/></head><body><div id="__next"><div class="layout_container__3sC0E"><header class="layout_header__3KufH"><a href="/"><img src="/images/profile.png" class="layout_headerImage__1Y87s utils_borderCircle__16bu1" alt="Hai Sam"/></a><h2 class="utils_headingLg__3uZpz"><a class="utils_colorInherit__rOQns" href="/">Hai Sam</a></h2></header><main><article class="utils_article__HvuVf"><h1 class="utils_headingXl__3wKvI">Cấu trúc dữ liệu trong Go: Interfaces</h1><div class="utils_lightText__3895Y"><time dateTime="2020-12-27">December 27, 2020</time></div><div><h1>1. Giới thiệu</h1>
<p>Go cung cấp một cơ chế dể cập nhật biến, và kiểm tra giá trị của nó lúc runtime, để gọi hàm,… mà không cần biết về kiểu dữ liệu của nó lúc biên dịch. Cơ chế này gọi là <code>reflection</code>. Ta có thể xem định nghĩa về <code>reflection</code> trên <a href="https://en.wikipedia.org/wiki/Reflective_programming">Wikipedia</a></p>
<blockquote>
<p>In computer science, reflection programming is the ability of a process to examine, introspect, and modify its own structure and behavior.[1]</p>
</blockquote>
<p>Trong computer science, <code>reflection programming</code> là khả năng của một process để thực thi, kiểm tra và thay đổi cấu trúc và hành vi của chính nó.</p>
<h1>2. Tại sao lại cần Reflection?</h1>
<p>Đôi khi chúng ta cần viết một hàm có khả năng hỗ trợ nhiều kiểu dữ liệu không phải là những interface thông thường, hoặc là chưa tồn tại ở thời điểm mình viết function, được diễn đạt ở dạng chưa biết trước, … Ví dụ như là phần logic của hàm <code>fmt.Fprintf</code>, mà ta có thể dùng để in bất cứ kiểu dữ liệu gì mình muốn. Để minh hoạ ta thử xây dựng hàm <code>fmt.Sprint</code>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sprint</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>{})</span> <span class="hljs-title">string</span></span> {
  <span class="hljs-keyword">type</span> stringer <span class="hljs-keyword">interface</span> {
    String() <span class="hljs-keyword">string</span>
  }

  <span class="hljs-keyword">switch</span> x := x.(<span class="hljs-keyword">type</span>) {
    <span class="hljs-keyword">case</span> stringer:
      <span class="hljs-keyword">return</span> x.String()
    <span class="hljs-keyword">case</span> <span class="hljs-keyword">string</span>:
      <span class="hljs-keyword">return</span> x
    <span class="hljs-keyword">case</span> <span class="hljs-keyword">int</span>:
      <span class="hljs-keyword">return</span> strconv.Itoa(x)
    <span class="hljs-comment">// ...tương tự cho các trường hợp int16, uint32,...</span>
    <span class="hljs-keyword">case</span> <span class="hljs-keyword">bool</span>:
      <span class="hljs-keyword">if</span> x {
          <span class="hljs-keyword">return</span> <span class="hljs-string">"true"</span>
      }
      <span class="hljs-keyword">return</span> <span class="hljs-string">"false"</span>
    <span class="hljs-keyword">default</span>:
      <span class="hljs-comment">// array, chan, func, map, pointer, slice, struct</span>
      <span class="hljs-keyword">return</span> <span class="hljs-string">"???"</span>
  }
}
</code></pre>
<p>Nhưng còn đối với các trường hợp khác như <code>[]float64, map[string][]string</code>,… ta có thể cứ tiếp tục thêm vào case nhưng những kiểu dữ liệu này là vô tận. Và cả những kiểu dữ liệu tự định nghĩa nữa. Trong trường hợp này điều chúng ta cần chính là reflection.</p>
<h1>3. Type và Interface</h1>
<p>Bởi vì reflection được xây dựng dựa trên hệ thống kiểu dữ liệu (type) nên ta sẽ bắt đầu bằng việc nhắc lại hệ thống kiểu dữ liệu trong Go</p>
<p>Go là <code>statically typed</code> có nghĩa là kiểu dữ liệu tĩnh cố định không giống như Python hay Java là <code>dynamically typed</code>, mỗi biến sẽ có một kiểu dữ liệu tĩnh cố định và được xác định lúc biên dịch như là int, float32, *Mytype, …Nếu chúng ta khai báo</p>
<pre class="hljs"><code><span class="hljs-keyword">type</span> MyInt <span class="hljs-keyword">int</span>

<span class="hljs-keyword">var</span> i <span class="hljs-keyword">int</span>
<span class="hljs-keyword">var</span> j MyInt
</code></pre>
<p>thì i sẽ có kiểu int, j có kiểu là MyInt. các biến i, j có kiểu dữ liệu khác nhau mặc dù ở ẩn giấu bên trong chúng là cùng một kiểu, chúng không được assign cho lẫn nhau mà không sử dụng hàm convertion.</p>
<p>Một loại kiểu dữ liệu quan trọng là kiểu interface, sẽ đại diện cho một tập hợp các method. Một biến interface có thể chứa bất cứ giá trị concrete (không phải interface) nào mà thoả mãn interface đó (bằng cách implement tất cả các methods mà interface đó định nghĩa). Ta có thể tham khảo ví dụ mọi người hay sử dụng trong <a href="https://golang.org/pkg/io/">io.package</a></p>
<pre class="hljs"><code><span class="hljs-comment">// Reader là interface wrap hàm Read</span>
<span class="hljs-keyword">type</span> Reader <span class="hljs-keyword">interface</span> {
  Read(p []<span class="hljs-keyword">byte</span>) (n <span class="hljs-keyword">int</span>, err error)
}
<span class="hljs-comment">// Writer là interface wrap hàm Write</span>
<span class="hljs-keyword">type</span> Writer <span class="hljs-keyword">interface</span> {
  Write(p []<span class="hljs-keyword">byte</span>) (n <span class="hljs-keyword">int</span>, err error)
}
</code></pre>
<p>Bất cứ kiểu nào mà implement hàm <code>Read</code> (hoặc <code>Write</code>) được gọi là implement <code>io.Reader</code> (hoặc <code>io.Writer</code>) và có thể chứa bất cứ giá trị nào mà có kiểu dữ liệu có chứa <code>Read</code> method</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> r io.Reader
r = os.Stdin
r = bufio.NewReader(r)
r = <span class="hljs-built_in">new</span>(bytes.Buffer)
<span class="hljs-comment">// and so on</span>
</code></pre>
<p>Điều quan trọng cần phải ghi nhớ là dù cho r có chứa bất cứ giá trị nào thì kiểu dữ liệu của nó luôn là <code>io.Reader</code> bởi vì Go là <code>statically typed</code> và kiểu dữ liệu tĩnh của r là <code>io.Reader</code>.</p>
<p>Một ví dụ rất quan trọng khác của interface là kiểu interface rỗng: <code>interface {}</code>
Nó đại diện một tập hợp rỗng các methods, và vì vậy nó sẽ được thoả mãn bởi bất cứ kiểu dữ liệu nào.</p>
<h1>4. Biểu diễn của một interface</h1>
<p>Về chi tiết bạn có thể tham khảo bài viết của Russ Cox ở <a href="https://research.swtch.com/2009/12/go-data-structures-interfaces.html">đây</a>.
Tôi sẽ tóm tắt lại nội dung của nó ở đây</p>
<p>Một biến của kiểu interface sẽ chứa một cặp: giá trị concrete được gán cho biến đó, và phần mô tả kiểu dữ liệu của nó.</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> r io.Reader
tty, err := os.OpenFile(<span class="hljs-string">"/dev/tty"</span>, os.O_RDWR, <span class="hljs-number">0</span>)
<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err
}
r = tty
</code></pre>
<p>r chứa một cặp (value, type), (tty, *os.File). Chú ý ở đây <code>*os.File</code>hiện thực các methods khác ngoài hàm Read; mặc dù giá trị của interface chỉ cung cấp access vào duy nhất hàm<code>Read</code> nhưng giá trị bên trong của nó chứa đầy đủ tất cả các thông tin về kiểu dữ liệu của giá trị đó. Chính vì vậy mà ta có thể implement như dưới này:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> w io.Writer
w = r.(io.Writer)
</code></pre>
<p>Đây là một kiểu <code>type assertion</code>, nó kiểm tra kiểu dữ liệu bên trong của r có implement io.Writer hay không, và vì vậy mà ta có thể gán nó cho w. Sau khi assign, w sẽ chứa cặp giá trị giống với cặp giá trị của r (tty, *os.File). Kiểu static sẽ xác định những method nào sẽ được gọi từ biến interface, mặc dù giá trị concrete bên trong của nó có thể có nhiều methods khác nữa.</p>
<p>Tiếp tục chúng ta có thể làm như dưới này:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> empty <span class="hljs-keyword">interface</span>{}
empty = w
</code></pre>
<p>Và biến empty của chúng ta một lần nữa lại chứa cùng cặp giá trị (tty, *os.File)</p>
<p>Điều cần nhớ ở đây là cặp giá trị bên trong một interface luôn luôn là (value, concrete type) không thể có cặp giá trị (value, interface type). Interface không chứa giá trị của interface.</p>
<h1>5. Các nguyên tắc của reflection</h1>
<h2>5.1. Reflection đi từ giá trị của interface đến reflection object</h2>
<p>Về cơ bản, reflection chỉ là cơ chế để kiểm tra cặp kiểu và giá trị chứa bên trong biến interface. Để bắt đầu có hai điều ta cần phải biết về <a href="https://golang.org/pkg/reflect/">package reflect</a>: <a href="https://golang.org/pkg/reflect/#Type">Type</a> và <a href="https://golang.org/pkg/reflect/#Value">Value</a>. Những kiểu này cung cấp access đến nội dung của một biến interface, và hai function <code>reflect.TypeOf</code> và <code>reflect.ValueOf</code> truy xuất <code>reflect.Type</code> và <code>reflect.Value</code> từ biến interface. (Thực ra từ <code>reflect.Value</code> ta có thể dễ dàng lấy được thông tin về <code>reflect.Type</code> nhưng hãy tách biệt hai khái niệm này ra khỏi nhau từ bây giờ).</p>
<p>Bắt đầu với <code>TypeOf</code>:</p>
<pre class="hljs"><code><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"fmt"</span>
    <span class="hljs-string">"reflect"</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">var</span> x <span class="hljs-keyword">float64</span> = <span class="hljs-number">3.4</span>
    fmt.Println(<span class="hljs-string">"type:"</span>, reflect.TypeOf(x))
}
</code></pre>
<p>Chương trình này sẽ in ra <code>type: float64</code></p>
<p>Bạn sẽ thắc mắc interface ở đây là cái nào, bởi vì chương trình này giống như là kiểu truyền một biến x float64, không phải là một giá trị interface, vào hàm <code>reflect.TypeOf</code>. Tuy nhiên theo mô tả ở đây <a href="https://golang.org/pkg/reflect/#TypeOf">godoc report</a> kí hiệu (signature) của <code>reflect.TypeOf</code> bao gồm cả interface rỗng.</p>
<pre class="hljs"><code><span class="hljs-comment">// TypeOf returns the reflection Type of the value in the interface{}.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TypeOf</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>{})</span> <span class="hljs-title">Type</span></span>
</code></pre>
<p>Khi chúng ta gọi <code>reflect.TypeOf(x)</code>, x đầu tiên được chứa vào một interface rỗng, sau đó interface rỗng này sẽ được truyền vào <code>reflect.TypeOf</code> và bung ra lại thông tin kiểu dữ liệu và tất nhiên là cả thông tin về value.</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> x <span class="hljs-keyword">float64</span> = <span class="hljs-number">3.4</span>
fmt.Println(<span class="hljs-string">"value:"</span>, reflect.ValueOf(x).String())
</code></pre>
<p>sẽ in ra <code>value: &lt;float64 Value&gt;</code></p>
<p>Ở đây ta phải gọi hàm String bởi vì <code>fmt.Println</code> sẽ tự động truy xuất vào bên trong reflect.Value để hiển thị giá trị trị concrete bên trong của nó. hàm String thì không làm như vậy</p>
<p>Cả <code>reflect.Value</code> và <code>reflect.Type</code> có nhiều method, chúng ta hãy cũng nhau kiểm tra chúng. Một ví dụ quan trọng là <code>Value</code> có một method tên là <code>Type</code> trả về type của reflect.Value. Cả hai <code>Value</code> và <code>Type</code> đều có method <code>Kind</code> trả về một hằng số mô tả loại dữ liệu gì được chứa Uint, Float64, Slice,… Và các method của <code>Value</code> như <code>Int</code> và <code>Float</code> cho phép ta lấy giá trị được lưu bên trong:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> x <span class="hljs-keyword">float64</span> = <span class="hljs-number">3.4</span>
v := reflect.ValueOf(x)
fmt.Println(<span class="hljs-string">"type:"</span>, v.Type())
fmt.Println(<span class="hljs-string">"kind is float64:"</span>, v.Kind() == reflect.Float64)
fmt.Println(<span class="hljs-string">"value:"</span>, v.Float())
</code></pre>
<p>sẽ in ra</p>
<pre class="hljs"><code><span class="hljs-built_in">type</span>: float64
kind is float64: <span class="hljs-literal">true</span>
value: 3.4
</code></pre>
<p>Còn có những hàm như <code>SetInt</code> và <code>SetFloat</code> nhưng để sử dụng được chúng ta phải hiểu rõ cách gán giá trị sẽ được mô tả ở nguyên tắc thứ 3.</p>
<p>Trong thư viện reflection còn có những đặc tính khác cần được mô tả. Để cho đơn giản method setter và getter của <code>Value</code> sẽ thao tác trên kiểu dữ liệu lớn nhất mà có thể chứa giá trị. ví dụ như là <code>int64</code> cho tất cả giá trị integer, điều này có nghĩa là method <code>Int</code> của <code>Value</code> sẽ trả về kiểu <code>int64</code> và method <code>SetInt</code> sẽ nhận kiểu <code>int64</code> làm thông số đầu vào.</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> x <span class="hljs-keyword">uint8</span> = <span class="hljs-string">'x'</span>
v := reflect.ValueOf(x)
fmt.Println(<span class="hljs-string">"type:"</span>, v.Type())                            <span class="hljs-comment">// uint8.</span>
fmt.Println(<span class="hljs-string">"kind is uint8: "</span>, v.Kind() == reflect.Uint8) <span class="hljs-comment">// true.</span>
x = <span class="hljs-keyword">uint8</span>(v.Uint())                                       <span class="hljs-comment">// v.Uint returns a uint64.</span>
</code></pre>
<p>Đặc tính thứ hai là <code>Kind</code> sẽ mô tả kiểu dữ liệu ẩn bên trong chứ không phải là kiểu static, nếu một reflection object chứa một giá trị của kiểu dữ liệu tự định nghĩa MyType, như sau</p>
<pre class="hljs"><code><span class="hljs-keyword">type</span> MyInt <span class="hljs-keyword">int</span>
<span class="hljs-keyword">var</span> x MyInt = <span class="hljs-number">7</span>
v := reflect.ValueOf(x)
</code></pre>
<p>Method <code>Kind</code> của v vẫn sẽ là reflect.Int, mặc dù kiểu dữ liệu static của nó là MyInt, điều này thì khác với method <code>Type</code></p>
<h2>5.2. Reflection đi từ reflection object đến interface value.</h2>
<h2>5.3. Để chỉnh sửa một reflection object, value cần phải có thể được set.</h2>
<h1>Reference</h1>
<p><a href="https://blog.golang.org/laws-of-reflection">https://blog.golang.org/laws-of-reflection</a></p>
<p><a href="https://www.gopl.io/">The Go Programming Language</a>, Chapter 12. Reflection</p>
<p><a href="https://en.wikipedia.org/wiki/Reflective_programming">https://en.wikipedia.org/wiki/Reflective_programming</a></p>
<p><a href="https://yourbasic.org/golang/generics/">https://yourbasic.org/golang/generics/</a></p>
<p><a href="https://dev.to/designpuddle/coding-concepts---reflection-4d2c">https://dev.to/designpuddle/coding-concepts---reflection-4d2c</a></p>
</div></article></main><div class="layout_backToHome__3Z5L9"><a href="/">← Back to home</a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"reflection_in_go","contentHtml":"\u003ch1\u003e1. Giới thiệu\u003c/h1\u003e\n\u003cp\u003eGo cung cấp một cơ chế dể cập nhật biến, và kiểm tra giá trị của nó lúc runtime, để gọi hàm,… mà không cần biết về kiểu dữ liệu của nó lúc biên dịch. Cơ chế này gọi là \u003ccode\u003ereflection\u003c/code\u003e. Ta có thể xem định nghĩa về \u003ccode\u003ereflection\u003c/code\u003e trên \u003ca href=\"https://en.wikipedia.org/wiki/Reflective_programming\"\u003eWikipedia\u003c/a\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIn computer science, reflection programming is the ability of a process to examine, introspect, and modify its own structure and behavior.[1]\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eTrong computer science, \u003ccode\u003ereflection programming\u003c/code\u003e là khả năng của một process để thực thi, kiểm tra và thay đổi cấu trúc và hành vi của chính nó.\u003c/p\u003e\n\u003ch1\u003e2. Tại sao lại cần Reflection?\u003c/h1\u003e\n\u003cp\u003eĐôi khi chúng ta cần viết một hàm có khả năng hỗ trợ nhiều kiểu dữ liệu không phải là những interface thông thường, hoặc là chưa tồn tại ở thời điểm mình viết function, được diễn đạt ở dạng chưa biết trước, … Ví dụ như là phần logic của hàm \u003ccode\u003efmt.Fprintf\u003c/code\u003e, mà ta có thể dùng để in bất cứ kiểu dữ liệu gì mình muốn. Để minh hoạ ta thử xây dựng hàm \u003ccode\u003efmt.Sprint\u003c/code\u003e:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eSprint\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(x \u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e{})\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003estring\u003c/span\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e stringer \u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e {\n    String() \u003cspan class=\"hljs-keyword\"\u003estring\u003c/span\u003e\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e x := x.(\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e stringer:\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e x.String()\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estring\u003c/span\u003e:\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e x\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e:\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e strconv.Itoa(x)\n    \u003cspan class=\"hljs-comment\"\u003e// ...tương tự cho các trường hợp int16, uint32,...\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ebool\u003c/span\u003e:\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e x {\n          \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"true\"\u003c/span\u003e\n      }\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"false\"\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e:\n      \u003cspan class=\"hljs-comment\"\u003e// array, chan, func, map, pointer, slice, struct\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"???\"\u003c/span\u003e\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNhưng còn đối với các trường hợp khác như \u003ccode\u003e[]float64, map[string][]string\u003c/code\u003e,… ta có thể cứ tiếp tục thêm vào case nhưng những kiểu dữ liệu này là vô tận. Và cả những kiểu dữ liệu tự định nghĩa nữa. Trong trường hợp này điều chúng ta cần chính là reflection.\u003c/p\u003e\n\u003ch1\u003e3. Type và Interface\u003c/h1\u003e\n\u003cp\u003eBởi vì reflection được xây dựng dựa trên hệ thống kiểu dữ liệu (type) nên ta sẽ bắt đầu bằng việc nhắc lại hệ thống kiểu dữ liệu trong Go\u003c/p\u003e\n\u003cp\u003eGo là \u003ccode\u003estatically typed\u003c/code\u003e có nghĩa là kiểu dữ liệu tĩnh cố định không giống như Python hay Java là \u003ccode\u003edynamically typed\u003c/code\u003e, mỗi biến sẽ có một kiểu dữ liệu tĩnh cố định và được xác định lúc biên dịch như là int, float32, *Mytype, …Nếu chúng ta khai báo\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e MyInt \u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e j MyInt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ethì i sẽ có kiểu int, j có kiểu là MyInt. các biến i, j có kiểu dữ liệu khác nhau mặc dù ở ẩn giấu bên trong chúng là cùng một kiểu, chúng không được assign cho lẫn nhau mà không sử dụng hàm convertion.\u003c/p\u003e\n\u003cp\u003eMột loại kiểu dữ liệu quan trọng là kiểu interface, sẽ đại diện cho một tập hợp các method. Một biến interface có thể chứa bất cứ giá trị concrete (không phải interface) nào mà thoả mãn interface đó (bằng cách implement tất cả các methods mà interface đó định nghĩa). Ta có thể tham khảo ví dụ mọi người hay sử dụng trong \u003ca href=\"https://golang.org/pkg/io/\"\u003eio.package\u003c/a\u003e\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// Reader là interface wrap hàm Read\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e Reader \u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e {\n  Read(p []\u003cspan class=\"hljs-keyword\"\u003ebyte\u003c/span\u003e) (n \u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e, err error)\n}\n\u003cspan class=\"hljs-comment\"\u003e// Writer là interface wrap hàm Write\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e Writer \u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e {\n  Write(p []\u003cspan class=\"hljs-keyword\"\u003ebyte\u003c/span\u003e) (n \u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e, err error)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBất cứ kiểu nào mà implement hàm \u003ccode\u003eRead\u003c/code\u003e (hoặc \u003ccode\u003eWrite\u003c/code\u003e) được gọi là implement \u003ccode\u003eio.Reader\u003c/code\u003e (hoặc \u003ccode\u003eio.Writer\u003c/code\u003e) và có thể chứa bất cứ giá trị nào mà có kiểu dữ liệu có chứa \u003ccode\u003eRead\u003c/code\u003e method\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e r io.Reader\nr = os.Stdin\nr = bufio.NewReader(r)\nr = \u003cspan class=\"hljs-built_in\"\u003enew\u003c/span\u003e(bytes.Buffer)\n\u003cspan class=\"hljs-comment\"\u003e// and so on\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eĐiều quan trọng cần phải ghi nhớ là dù cho r có chứa bất cứ giá trị nào thì kiểu dữ liệu của nó luôn là \u003ccode\u003eio.Reader\u003c/code\u003e bởi vì Go là \u003ccode\u003estatically typed\u003c/code\u003e và kiểu dữ liệu tĩnh của r là \u003ccode\u003eio.Reader\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eMột ví dụ rất quan trọng khác của interface là kiểu interface rỗng: \u003ccode\u003einterface {}\u003c/code\u003e\nNó đại diện một tập hợp rỗng các methods, và vì vậy nó sẽ được thoả mãn bởi bất cứ kiểu dữ liệu nào.\u003c/p\u003e\n\u003ch1\u003e4. Biểu diễn của một interface\u003c/h1\u003e\n\u003cp\u003eVề chi tiết bạn có thể tham khảo bài viết của Russ Cox ở \u003ca href=\"https://research.swtch.com/2009/12/go-data-structures-interfaces.html\"\u003eđây\u003c/a\u003e.\nTôi sẽ tóm tắt lại nội dung của nó ở đây\u003c/p\u003e\n\u003cp\u003eMột biến của kiểu interface sẽ chứa một cặp: giá trị concrete được gán cho biến đó, và phần mô tả kiểu dữ liệu của nó.\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e r io.Reader\ntty, err := os.OpenFile(\u003cspan class=\"hljs-string\"\u003e\"/dev/tty\"\u003c/span\u003e, os.O_RDWR, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e, err\n}\nr = tty\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003er chứa một cặp (value, type), (tty, *os.File). Chú ý ở đây \u003ccode\u003e*os.File\u003c/code\u003ehiện thực các methods khác ngoài hàm Read; mặc dù giá trị của interface chỉ cung cấp access vào duy nhất hàm\u003ccode\u003eRead\u003c/code\u003e nhưng giá trị bên trong của nó chứa đầy đủ tất cả các thông tin về kiểu dữ liệu của giá trị đó. Chính vì vậy mà ta có thể implement như dưới này:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e w io.Writer\nw = r.(io.Writer)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eĐây là một kiểu \u003ccode\u003etype assertion\u003c/code\u003e, nó kiểm tra kiểu dữ liệu bên trong của r có implement io.Writer hay không, và vì vậy mà ta có thể gán nó cho w. Sau khi assign, w sẽ chứa cặp giá trị giống với cặp giá trị của r (tty, *os.File). Kiểu static sẽ xác định những method nào sẽ được gọi từ biến interface, mặc dù giá trị concrete bên trong của nó có thể có nhiều methods khác nữa.\u003c/p\u003e\n\u003cp\u003eTiếp tục chúng ta có thể làm như dưới này:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e empty \u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e{}\nempty = w\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eVà biến empty của chúng ta một lần nữa lại chứa cùng cặp giá trị (tty, *os.File)\u003c/p\u003e\n\u003cp\u003eĐiều cần nhớ ở đây là cặp giá trị bên trong một interface luôn luôn là (value, concrete type) không thể có cặp giá trị (value, interface type). Interface không chứa giá trị của interface.\u003c/p\u003e\n\u003ch1\u003e5. Các nguyên tắc của reflection\u003c/h1\u003e\n\u003ch2\u003e5.1. Reflection đi từ giá trị của interface đến reflection object\u003c/h2\u003e\n\u003cp\u003eVề cơ bản, reflection chỉ là cơ chế để kiểm tra cặp kiểu và giá trị chứa bên trong biến interface. Để bắt đầu có hai điều ta cần phải biết về \u003ca href=\"https://golang.org/pkg/reflect/\"\u003epackage reflect\u003c/a\u003e: \u003ca href=\"https://golang.org/pkg/reflect/#Type\"\u003eType\u003c/a\u003e và \u003ca href=\"https://golang.org/pkg/reflect/#Value\"\u003eValue\u003c/a\u003e. Những kiểu này cung cấp access đến nội dung của một biến interface, và hai function \u003ccode\u003ereflect.TypeOf\u003c/code\u003e và \u003ccode\u003ereflect.ValueOf\u003c/code\u003e truy xuất \u003ccode\u003ereflect.Type\u003c/code\u003e và \u003ccode\u003ereflect.Value\u003c/code\u003e từ biến interface. (Thực ra từ \u003ccode\u003ereflect.Value\u003c/code\u003e ta có thể dễ dàng lấy được thông tin về \u003ccode\u003ereflect.Type\u003c/code\u003e nhưng hãy tách biệt hai khái niệm này ra khỏi nhau từ bây giờ).\u003c/p\u003e\n\u003cp\u003eBắt đầu với \u003ccode\u003eTypeOf\u003c/code\u003e:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003epackage\u003c/span\u003e main\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e (\n    \u003cspan class=\"hljs-string\"\u003e\"fmt\"\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"reflect\"\u003c/span\u003e\n)\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e x \u003cspan class=\"hljs-keyword\"\u003efloat64\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e3.4\u003c/span\u003e\n    fmt.Println(\u003cspan class=\"hljs-string\"\u003e\"type:\"\u003c/span\u003e, reflect.TypeOf(x))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eChương trình này sẽ in ra \u003ccode\u003etype: float64\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eBạn sẽ thắc mắc interface ở đây là cái nào, bởi vì chương trình này giống như là kiểu truyền một biến x float64, không phải là một giá trị interface, vào hàm \u003ccode\u003ereflect.TypeOf\u003c/code\u003e. Tuy nhiên theo mô tả ở đây \u003ca href=\"https://golang.org/pkg/reflect/#TypeOf\"\u003egodoc report\u003c/a\u003e kí hiệu (signature) của \u003ccode\u003ereflect.TypeOf\u003c/code\u003e bao gồm cả interface rỗng.\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// TypeOf returns the reflection Type of the value in the interface{}.\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eTypeOf\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(i \u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e{})\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eType\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eKhi chúng ta gọi \u003ccode\u003ereflect.TypeOf(x)\u003c/code\u003e, x đầu tiên được chứa vào một interface rỗng, sau đó interface rỗng này sẽ được truyền vào \u003ccode\u003ereflect.TypeOf\u003c/code\u003e và bung ra lại thông tin kiểu dữ liệu và tất nhiên là cả thông tin về value.\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e x \u003cspan class=\"hljs-keyword\"\u003efloat64\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e3.4\u003c/span\u003e\nfmt.Println(\u003cspan class=\"hljs-string\"\u003e\"value:\"\u003c/span\u003e, reflect.ValueOf(x).String())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003esẽ in ra \u003ccode\u003evalue: \u0026lt;float64 Value\u0026gt;\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eỞ đây ta phải gọi hàm String bởi vì \u003ccode\u003efmt.Println\u003c/code\u003e sẽ tự động truy xuất vào bên trong reflect.Value để hiển thị giá trị trị concrete bên trong của nó. hàm String thì không làm như vậy\u003c/p\u003e\n\u003cp\u003eCả \u003ccode\u003ereflect.Value\u003c/code\u003e và \u003ccode\u003ereflect.Type\u003c/code\u003e có nhiều method, chúng ta hãy cũng nhau kiểm tra chúng. Một ví dụ quan trọng là \u003ccode\u003eValue\u003c/code\u003e có một method tên là \u003ccode\u003eType\u003c/code\u003e trả về type của reflect.Value. Cả hai \u003ccode\u003eValue\u003c/code\u003e và \u003ccode\u003eType\u003c/code\u003e đều có method \u003ccode\u003eKind\u003c/code\u003e trả về một hằng số mô tả loại dữ liệu gì được chứa Uint, Float64, Slice,… Và các method của \u003ccode\u003eValue\u003c/code\u003e như \u003ccode\u003eInt\u003c/code\u003e và \u003ccode\u003eFloat\u003c/code\u003e cho phép ta lấy giá trị được lưu bên trong:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e x \u003cspan class=\"hljs-keyword\"\u003efloat64\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e3.4\u003c/span\u003e\nv := reflect.ValueOf(x)\nfmt.Println(\u003cspan class=\"hljs-string\"\u003e\"type:\"\u003c/span\u003e, v.Type())\nfmt.Println(\u003cspan class=\"hljs-string\"\u003e\"kind is float64:\"\u003c/span\u003e, v.Kind() == reflect.Float64)\nfmt.Println(\u003cspan class=\"hljs-string\"\u003e\"value:\"\u003c/span\u003e, v.Float())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003esẽ in ra\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-built_in\"\u003etype\u003c/span\u003e: float64\nkind is float64: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\nvalue: 3.4\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCòn có những hàm như \u003ccode\u003eSetInt\u003c/code\u003e và \u003ccode\u003eSetFloat\u003c/code\u003e nhưng để sử dụng được chúng ta phải hiểu rõ cách gán giá trị sẽ được mô tả ở nguyên tắc thứ 3.\u003c/p\u003e\n\u003cp\u003eTrong thư viện reflection còn có những đặc tính khác cần được mô tả. Để cho đơn giản method setter và getter của \u003ccode\u003eValue\u003c/code\u003e sẽ thao tác trên kiểu dữ liệu lớn nhất mà có thể chứa giá trị. ví dụ như là \u003ccode\u003eint64\u003c/code\u003e cho tất cả giá trị integer, điều này có nghĩa là method \u003ccode\u003eInt\u003c/code\u003e của \u003ccode\u003eValue\u003c/code\u003e sẽ trả về kiểu \u003ccode\u003eint64\u003c/code\u003e và method \u003ccode\u003eSetInt\u003c/code\u003e sẽ nhận kiểu \u003ccode\u003eint64\u003c/code\u003e làm thông số đầu vào.\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e x \u003cspan class=\"hljs-keyword\"\u003euint8\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'x'\u003c/span\u003e\nv := reflect.ValueOf(x)\nfmt.Println(\u003cspan class=\"hljs-string\"\u003e\"type:\"\u003c/span\u003e, v.Type())                            \u003cspan class=\"hljs-comment\"\u003e// uint8.\u003c/span\u003e\nfmt.Println(\u003cspan class=\"hljs-string\"\u003e\"kind is uint8: \"\u003c/span\u003e, v.Kind() == reflect.Uint8) \u003cspan class=\"hljs-comment\"\u003e// true.\u003c/span\u003e\nx = \u003cspan class=\"hljs-keyword\"\u003euint8\u003c/span\u003e(v.Uint())                                       \u003cspan class=\"hljs-comment\"\u003e// v.Uint returns a uint64.\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eĐặc tính thứ hai là \u003ccode\u003eKind\u003c/code\u003e sẽ mô tả kiểu dữ liệu ẩn bên trong chứ không phải là kiểu static, nếu một reflection object chứa một giá trị của kiểu dữ liệu tự định nghĩa MyType, như sau\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e MyInt \u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e x MyInt = \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e\nv := reflect.ValueOf(x)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMethod \u003ccode\u003eKind\u003c/code\u003e của v vẫn sẽ là reflect.Int, mặc dù kiểu dữ liệu static của nó là MyInt, điều này thì khác với method \u003ccode\u003eType\u003c/code\u003e\u003c/p\u003e\n\u003ch2\u003e5.2. Reflection đi từ reflection object đến interface value.\u003c/h2\u003e\n\u003ch2\u003e5.3. Để chỉnh sửa một reflection object, value cần phải có thể được set.\u003c/h2\u003e\n\u003ch1\u003eReference\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://blog.golang.org/laws-of-reflection\"\u003ehttps://blog.golang.org/laws-of-reflection\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.gopl.io/\"\u003eThe Go Programming Language\u003c/a\u003e, Chapter 12. Reflection\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Reflective_programming\"\u003ehttps://en.wikipedia.org/wiki/Reflective_programming\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://yourbasic.org/golang/generics/\"\u003ehttps://yourbasic.org/golang/generics/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://dev.to/designpuddle/coding-concepts---reflection-4d2c\"\u003ehttps://dev.to/designpuddle/coding-concepts---reflection-4d2c\u003c/a\u003e\u003c/p\u003e\n","title":"Cấu trúc dữ liệu trong Go: Interfaces","date":"2020-12-27"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"reflection_in_go"},"buildId":"qRITv4baP-BSvIAJ11jf9","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"name":"viewport","content":"width=device-width"}],["meta",{"charSet":"utf-8"}],["link",{"rel":"icon","href":"/favicon.ico"}],["meta",{"name":"description","content":"My personal blog"}],["meta",{"property":"og:image","content":"https://og-image.now.sh/Hai%20Sam's%20Blog.png?theme=light\u0026md=0\u0026fontSize=75px\u0026images=https%3A%2F%2Fassets.zeit.co%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"}],["meta",{"name":"og:title","content":"Hai Sam's Blog"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["title",{"children":"Cấu trúc dữ liệu trong Go: Interfaces"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-11c8eba6a84e3fddec04.js"></script><script src="/_next/static/chunks/main-d283b4ab393ebd284c3e.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9ec1f7868b3e9d138cdd.js" async=""></script><script src="/_next/static/chunks/commons.e3c12cb767780eaa6561.js" async=""></script><script src="/_next/static/chunks/pages/_app-ded95831299dc0ee3969.js" async=""></script><script src="/_next/static/chunks/7989c093b81d86ddb0abfb342d5bc2e84730435d.a106123a322eba1d4442.js" async=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-f3a8cc6c89a99a8d726d.js" async=""></script><script src="/_next/static/qRITv4baP-BSvIAJ11jf9/_buildManifest.js" async=""></script><script src="/_next/static/qRITv4baP-BSvIAJ11jf9/_ssgManifest.js" async=""></script></body></html>