<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="icon" href="/favicon.ico"/><meta name="description" content="My personal blog"/><meta property="og:image" content="https://og-image.now.sh/Hai%20Sam&#x27;s%20Blog.png?theme=light&amp;md=0&amp;fontSize=75px&amp;images=https%3A%2F%2Fassets.zeit.co%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><meta name="og:title" content="Hai Sam&#x27;s Blog"/><meta name="twitter:card" content="summary_large_image"/><title>Thuật toán cơ bản: phân tích độ phức tạp giải thuật</title><link rel="preload" href="/_next/static/css/a7b17ee9c118794ec99f.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a7b17ee9c118794ec99f.css" data-n-g=""/><link rel="preload" href="/_next/static/css/ef8b6818b7474fff8094.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ef8b6818b7474fff8094.css" data-n-p=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-d283b4ab393ebd284c3e.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9ec1f7868b3e9d138cdd.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.e3c12cb767780eaa6561.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-ded95831299dc0ee3969.js" as="script"/><link rel="preload" href="/_next/static/chunks/7989c093b81d86ddb0abfb342d5bc2e84730435d.a106123a322eba1d4442.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/posts/%5Bid%5D-f3a8cc6c89a99a8d726d.js" as="script"/></head><body><div id="__next"><div class="layout_container__3sC0E"><header class="layout_header__3KufH"><a href="/"><img src="/images/profile.png" class="layout_headerImage__1Y87s utils_borderCircle__16bu1" alt="Hai Sam"/></a><h2 class="utils_headingLg__3uZpz"><a class="utils_colorInherit__rOQns" href="/">Hai Sam</a></h2></header><main><article class="utils_article__HvuVf"><h1 class="utils_headingXl__3wKvI">Thuật toán cơ bản: phân tích độ phức tạp giải thuật</h1><div class="utils_lightText__3895Y"><time dateTime="2020-10-24">October 24, 2020</time></div><div><h1>1. Giới thiệu</h1>
<p>Đối với một người làm về khoa học máy tính, thuật toán chắc chắn phải là một trong những khái niệm đầu tiên phải học.</p>
<p>Vậy thì thuật toán là gi?</p>
<p>Một thuật toán là một quá trình để thực hiện một task, thuật toán là ý tưởng bên trong của bất kì chương trình máy tính nghiêm chỉnh nào.</p>
<p>Ta có thể nói một thuật toán thì sẽ phải giải quyết một vấn đề nào đó và để giải quyết một vấn đề có thể có nhiều thuật toán khác nhau.</p>
<p>Ví dụ:</p>
<p>Vấn đề sắp xếp:</p>
<pre class="hljs"><code>- Input: Nhận vào một chuỗi các khoá x1, x2, x3, ...
- Output: Sắp xếp lại thứ tự của chuỗi đầu vào sao cho theo thứ tự x1' &lt;= x2' &lt;= x3' ...
</code></pre>
<p>Để giải quyết vấn đề sắp xếp ta có các thuật toán sắp xếp: merge sort, quick sort, insertion sort, selection sort, …</p>
<h1>2. Phân tích thuật toán</h1>
<p>Có nhiều thuật toán để giải quyết một vấn đề.</p>
<p>Vì vậy sẽ nảy sinh vấn đề làm sao để lựa chọn thuật toán nào cho vấn đề nào.</p>
<p>Để giải quyết vấn đề đó chúng ta sẽ phải phân tích thuật toán.</p>
<p>Có hai công cụ quan trọng để đánh giá thuật toán: mô hình RAM, Big-O</p>
<h2>2.1. Mô hình RAM</h2>
<ol>
<li>
<p>Mỗi thao tác đơn giản (+, -, *, /, if, call) tốn đúng một bước</p>
</li>
<li>
<p>Vòng lặp và hàm thì không phải là thao tác đơn giản và sẽ tốn nhiều hơn 1 bước để thực hiện</p>
</li>
<li>
<p>Mỗi thao tác truy xuất bộ nhớ sẽ tốn đúng một bước</p>
</li>
</ol>
<p>Hiển nhiên chúng ta có thể thấy các điều kiện ở trên chỉ có tính tương đối và không đúng với thực tiễn.</p>
<p>Nhưng khi áp dụng mô hình RAM nó lại khiến cho việc phân tích thuật toán trở nên đơn giản và hiệu quả.</p>
<h3>2.1.1 Độ phức tạp theo thời gian</h3>
<p>Khi áp dụng mô hình trên người ta thường sẽ để ý đến các trường hợp:</p>
<ol>
<li>
<p>Trường hợp tốt nhất (best-case) là số lượng bước ít nhất cần để thực hiện thuật toán</p>
</li>
<li>
<p>Trường hợp tệ nhất (worst-case) là số lượng bước nhiều nhất cần để thực hiện thuật toán</p>
</li>
<li>
<p>Trường hợp trung bình (average-case) là số lượng bước trung bình để thực hiện thuật toán</p>
</li>
</ol>
<p>Trường hợp tệ nhất đóng vai trò quan trọng trong thực tiễn và thường ta chỉ quan tâm đến nó mà bỏ qua hai trường hợp còn lại.</p>
<h3>2.1.2 Cách xác định độ phức tạp theo thời gian</h3>
<p>Độ phức tạp theo thời gian dùng để ước lượng thời gian cần thiết để thực thi giải thuật và được tính toán dựa vào số bước thực hiện các thao tác cơ bản.</p>
<p>Ví dụ: Hãy xác định thời gian thiện hiện thuật toán dưới đây</p>
<pre class="hljs"><code><span class="hljs-comment">// Tính toán tìm phần tử lớn nhất trong mảng</span>
Algorithm max(a):
    max ← a[<span class="hljs-number">0</span>]
    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span> to <span class="hljs-built_in">len</span>(a)<span class="hljs-number">-1</span>
        <span class="hljs-keyword">if</span> a[i] &gt; max
            max ← a[i]
    <span class="hljs-keyword">return</span> max
</code></pre>
<p>Câu trả lời chính xác tuỳ thuộc vào nhiều yếu tố như là giá trị đầu vào, ngôn ngữ lập trình và môi trường thực thi, trình biên dịch, hệ điều hành và phần cứng, …</p>
<p>Vì vậy chúng ta thường chỉ muốn ước lượng thời gian thực thi thuật toán tương đối chỉ dựa vào thuật toán và giá trị đầu vào.
Điều này có thể được thực hiện bằng cách chọn một thao tác cơ bản mà thuật toán lặp lại nhiều lần và tính toán độ phức tạp thời gian như là số thao tác cơ bản cần để thực hiện thuật toán với input array có độ dài n</p>
<p>Đối với thuật toán ở trên ta có thể chọn thao tác so sánh a[i] &gt; max làm thao tác cơ bản.</p>
<ol>
<li>
<p>Bởi vì phép toán so sánh được sử dụng xuyên suốt thuật toán nên là điều này sẽ cho phép phản ánh đúng đắn thời gian chạy của thuật toán</p>
</li>
<li>
<p>Hơn nữa thời gian thực hiện của phép so sánh là hằng số và không phụ thuộc vào kích thước của array.</p>
</li>
</ol>
<h4>2.1.2.1. Độ phức tạp thời gian tệ nhất (worst-case)</h4>
<p>Xem xét thuật toán dưới này:</p>
<pre class="hljs"><code><span class="hljs-comment">// Kiểm tra xem array a có chứa x.</span>
Algorithm contains(a, x):
    <span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span> to <span class="hljs-built_in">len</span>(a)<span class="hljs-number">-1</span>
        <span class="hljs-keyword">if</span> x == a[i]
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
</code></pre>
<p>Phép toán so sánh x == a[i] có thể được dùng làm phép toán cơ bản trong trường hợp này.
Tuy nhiên như chúng ta thấy trong trường hợp này số lượng phép toán so sánh được thực hiện không chỉ phụ thuộc vào số lượng phần tử array n mà còn phụ thộc vào giá trị của x và giá trị của các phần tử trong a.</p>
<ol>
<li>
<p>Nếu không tìm thấy x thì số phép toán so sánh là n</p>
</li>
<li>
<p>Nếu x == a[0] thì chỉ cần một phép so sánh .</p>
</li>
</ol>
<p>Vì lý do này mà thông thường ta sẽ chọn xác định trường hợp thời gian tệ nhất của thuật toán:</p>
<ol>
<li>
<p>Cho T1(n), T2(n), … là thời gian thực thi của tất cả các giá trị có thể có của input kích thước n</p>
</li>
<li>
<p>Độ phức tạp thời gian trong trường hợp tệ nhất sẽ là W(n) = max(T1(n), T2(n), …)</p>
</li>
</ol>
<p>Vì vậy độ phức thời gian trong trường hợp tệ nhất sẽ là n</p>
<h4>2.1.2.2 Độ phức tạp thời gian trung bình (average-case)</h4>
<p>Độ phức tạp thời gian trung bình thì ít phổ biến hơn, có thể được định nghĩa là số bước trung bình cần thiết để thực hiện thuật toán.</p>
<ol>
<li>
<p>Cho T1(n), T2(n), … là thời gian thực thi của tất cả các giá tri có thể có của input kích thước n, và P1(n), P2(n), …là xác xuất của những input này.</p>
</li>
<li>
<p>Độ phức tạp thời gian trung bình (average-case) được định nghĩa là P1(n)T1(n) + P2(n)T2(n) + …</p>
</li>
</ol>
<p>Độ phức tạp thời gian trung bình khó để tính toán và ý nghĩa của nó là chủ đề gây tranh cãi.</p>
<h2>2.2. Big-O</h2>
<p>Như ở trên ta có nói thời gian thực thi của một thuật toán phụ thuộc vào nhiều yếu tố và khó để xác định chính xác nó.
Vì vậy khi nói đến việc tính toán thời gian thực thi của thuật toán đó chính là thời gian ước lượng, việc này thì thực ra không gây ra vấn đề gì. Bởi vì trong khoa học máy tính thứ được quan tâm nhiều hơn đối với một thuật toán là thời gian thực thi của nó sẽ tăng nhanh như thế nào khi số lượng phần tử đầu vào thay đổi.</p>
<p>Từ đó khái niệm Big-O được ra đời.</p>
<p>Và sau đây là một định nghĩa toán học của Big-O</p>
<blockquote>
<p>Cho T(n) và f(n) là hai hàm số dương. Ta viết T(n) = O(f(n)) có nghĩa rằng c . f(n) là cận trên của T(n). Vì vậy tồn tại một hằng số c sao cho T(n) luôn luôn &lt;= c . f(n) với một số n đủ lớn (n &gt;= n0)</p>
</blockquote>
<p>Hay nói một cách dễ hiểu hơn:</p>
<blockquote>
<p>T(n) = O(f(n)) có nghĩa là T(n) không tăng nhanh hơn f(n).</p>
</blockquote>
<p>Lưu ý: Ngoài Big-O, còn có hai khái niệm khác Big Omega(Ω) và Big Thelta(Θ):</p>
<ol>
<li>
<p>Big Omega f(n) = Ω(g(n)) có nghĩa là c . g(n) là cận dưới của f(n), có tồn tại một số n &gt;= n0 sao cho f(n) luôn nhỏ hơn c . g(n)</p>
</li>
<li>
<p>Big Thelta f(n) = Θ(g(n)) có nghĩa là c1 . g(n) là cận dưới và c2 . g(n) là cận trên của f(n), có tồn tại một số n &gt;= n0 sao cho c1.g(n) &lt;= f(n) &lt;= c2.g(n)</p>
</li>
</ol>
<h3>2.2.1. Giới thiệu về một số hàm số tăng cơ bản</h3>
<h4>2.2.1.1 Hàm số hằng</h4>
<p>Đây là trường hợp đơn giản và lý tưởng nhất cho mọi thuật toán T(n) = O(1).</p>
<p>Theo như định nghĩa có nghĩa là sẽ tồn tại một giá trị n đủ lớn n &gt;= n0 sao cho T(n) luôn luôn nhỏ hơn một giá trị cố định không phụ thuộc vào n.</p>
<h3>2.2.1.2. Hàm số tuyến tính</h3>
<p>Đây là trường hợp thuật toán có độ phức tạp theo thời gian T(n) = O(n).</p>
<p>Áp dụng định nghĩa của Big-O, điều này có nghĩa là tồn tại một số n đủ lớn n0 sao cho thời gian thực thi của thuật toán luôn nhỏ hơn n</p>
<h3>2.2.1.3 Hàm số mũ</h3>
<p>Đây là trường hợp thuật toán có độ phức tạp theo thời gian T(n) = O(n2).</p>
<p>Một lần nữa áp dụng định nghĩa, điều này có nghĩa là tồn tại một số n đủ lớn sao cho thời gian thực thi của thuật toán luôn nhỏ hơn n2.</p>
<h3>2.2.1.4 Ví dụ về thay đổi thời gian thực thi theo đầu vào</h3>
<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcQ6MsN%2FbtqubeWgXC4%2FXqPDbr2YJLA03Gx5g9VIJk%2Fimg.jpg" alt="chart"></p>
<h1>Nguồn tham khảo</h1>
<ol>
<li>
<p><a href="https://yourbasic.org/">https://yourbasic.org/</a></p>
</li>
<li>
<p>The Algorithm Design Manual – Skiena, Steven S.</p>
</li>
</ol>
</div></article></main><div class="layout_backToHome__3Z5L9"><a href="/">← Back to home</a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"basic_algorithm","contentHtml":"\u003ch1\u003e1. Giới thiệu\u003c/h1\u003e\n\u003cp\u003eĐối với một người làm về khoa học máy tính, thuật toán chắc chắn phải là một trong những khái niệm đầu tiên phải học.\u003c/p\u003e\n\u003cp\u003eVậy thì thuật toán là gi?\u003c/p\u003e\n\u003cp\u003eMột thuật toán là một quá trình để thực hiện một task, thuật toán là ý tưởng bên trong của bất kì chương trình máy tính nghiêm chỉnh nào.\u003c/p\u003e\n\u003cp\u003eTa có thể nói một thuật toán thì sẽ phải giải quyết một vấn đề nào đó và để giải quyết một vấn đề có thể có nhiều thuật toán khác nhau.\u003c/p\u003e\n\u003cp\u003eVí dụ:\u003c/p\u003e\n\u003cp\u003eVấn đề sắp xếp:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e- Input: Nhận vào một chuỗi các khoá x1, x2, x3, ...\n- Output: Sắp xếp lại thứ tự của chuỗi đầu vào sao cho theo thứ tự x1' \u0026lt;= x2' \u0026lt;= x3' ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eĐể giải quyết vấn đề sắp xếp ta có các thuật toán sắp xếp: merge sort, quick sort, insertion sort, selection sort, …\u003c/p\u003e\n\u003ch1\u003e2. Phân tích thuật toán\u003c/h1\u003e\n\u003cp\u003eCó nhiều thuật toán để giải quyết một vấn đề.\u003c/p\u003e\n\u003cp\u003eVì vậy sẽ nảy sinh vấn đề làm sao để lựa chọn thuật toán nào cho vấn đề nào.\u003c/p\u003e\n\u003cp\u003eĐể giải quyết vấn đề đó chúng ta sẽ phải phân tích thuật toán.\u003c/p\u003e\n\u003cp\u003eCó hai công cụ quan trọng để đánh giá thuật toán: mô hình RAM, Big-O\u003c/p\u003e\n\u003ch2\u003e2.1. Mô hình RAM\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eMỗi thao tác đơn giản (+, -, *, /, if, call) tốn đúng một bước\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eVòng lặp và hàm thì không phải là thao tác đơn giản và sẽ tốn nhiều hơn 1 bước để thực hiện\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMỗi thao tác truy xuất bộ nhớ sẽ tốn đúng một bước\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eHiển nhiên chúng ta có thể thấy các điều kiện ở trên chỉ có tính tương đối và không đúng với thực tiễn.\u003c/p\u003e\n\u003cp\u003eNhưng khi áp dụng mô hình RAM nó lại khiến cho việc phân tích thuật toán trở nên đơn giản và hiệu quả.\u003c/p\u003e\n\u003ch3\u003e2.1.1 Độ phức tạp theo thời gian\u003c/h3\u003e\n\u003cp\u003eKhi áp dụng mô hình trên người ta thường sẽ để ý đến các trường hợp:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eTrường hợp tốt nhất (best-case) là số lượng bước ít nhất cần để thực hiện thuật toán\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eTrường hợp tệ nhất (worst-case) là số lượng bước nhiều nhất cần để thực hiện thuật toán\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eTrường hợp trung bình (average-case) là số lượng bước trung bình để thực hiện thuật toán\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eTrường hợp tệ nhất đóng vai trò quan trọng trong thực tiễn và thường ta chỉ quan tâm đến nó mà bỏ qua hai trường hợp còn lại.\u003c/p\u003e\n\u003ch3\u003e2.1.2 Cách xác định độ phức tạp theo thời gian\u003c/h3\u003e\n\u003cp\u003eĐộ phức tạp theo thời gian dùng để ước lượng thời gian cần thiết để thực thi giải thuật và được tính toán dựa vào số bước thực hiện các thao tác cơ bản.\u003c/p\u003e\n\u003cp\u003eVí dụ: Hãy xác định thời gian thiện hiện thuật toán dưới đây\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// Tính toán tìm phần tử lớn nhất trong mảng\u003c/span\u003e\nAlgorithm max(a):\n    max ← a[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e to \u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(a)\u003cspan class=\"hljs-number\"\u003e-1\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e a[i] \u0026gt; max\n            max ← a[i]\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e max\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCâu trả lời chính xác tuỳ thuộc vào nhiều yếu tố như là giá trị đầu vào, ngôn ngữ lập trình và môi trường thực thi, trình biên dịch, hệ điều hành và phần cứng, …\u003c/p\u003e\n\u003cp\u003eVì vậy chúng ta thường chỉ muốn ước lượng thời gian thực thi thuật toán tương đối chỉ dựa vào thuật toán và giá trị đầu vào.\nĐiều này có thể được thực hiện bằng cách chọn một thao tác cơ bản mà thuật toán lặp lại nhiều lần và tính toán độ phức tạp thời gian như là số thao tác cơ bản cần để thực hiện thuật toán với input array có độ dài n\u003c/p\u003e\n\u003cp\u003eĐối với thuật toán ở trên ta có thể chọn thao tác so sánh a[i] \u0026gt; max làm thao tác cơ bản.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eBởi vì phép toán so sánh được sử dụng xuyên suốt thuật toán nên là điều này sẽ cho phép phản ánh đúng đắn thời gian chạy của thuật toán\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eHơn nữa thời gian thực hiện của phép so sánh là hằng số và không phụ thuộc vào kích thước của array.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4\u003e2.1.2.1. Độ phức tạp thời gian tệ nhất (worst-case)\u003c/h4\u003e\n\u003cp\u003eXem xét thuật toán dưới này:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// Kiểm tra xem array a có chứa x.\u003c/span\u003e\nAlgorithm contains(a, x):\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e to \u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(a)\u003cspan class=\"hljs-number\"\u003e-1\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e x == a[i]\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePhép toán so sánh x == a[i] có thể được dùng làm phép toán cơ bản trong trường hợp này.\nTuy nhiên như chúng ta thấy trong trường hợp này số lượng phép toán so sánh được thực hiện không chỉ phụ thuộc vào số lượng phần tử array n mà còn phụ thộc vào giá trị của x và giá trị của các phần tử trong a.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eNếu không tìm thấy x thì số phép toán so sánh là n\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eNếu x == a[0] thì chỉ cần một phép so sánh .\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eVì lý do này mà thông thường ta sẽ chọn xác định trường hợp thời gian tệ nhất của thuật toán:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eCho T1(n), T2(n), … là thời gian thực thi của tất cả các giá trị có thể có của input kích thước n\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eĐộ phức tạp thời gian trong trường hợp tệ nhất sẽ là W(n) = max(T1(n), T2(n), …)\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eVì vậy độ phức thời gian trong trường hợp tệ nhất sẽ là n\u003c/p\u003e\n\u003ch4\u003e2.1.2.2 Độ phức tạp thời gian trung bình (average-case)\u003c/h4\u003e\n\u003cp\u003eĐộ phức tạp thời gian trung bình thì ít phổ biến hơn, có thể được định nghĩa là số bước trung bình cần thiết để thực hiện thuật toán.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eCho T1(n), T2(n), … là thời gian thực thi của tất cả các giá tri có thể có của input kích thước n, và P1(n), P2(n), …là xác xuất của những input này.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eĐộ phức tạp thời gian trung bình (average-case) được định nghĩa là P1(n)T1(n) + P2(n)T2(n) + …\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eĐộ phức tạp thời gian trung bình khó để tính toán và ý nghĩa của nó là chủ đề gây tranh cãi.\u003c/p\u003e\n\u003ch2\u003e2.2. Big-O\u003c/h2\u003e\n\u003cp\u003eNhư ở trên ta có nói thời gian thực thi của một thuật toán phụ thuộc vào nhiều yếu tố và khó để xác định chính xác nó.\nVì vậy khi nói đến việc tính toán thời gian thực thi của thuật toán đó chính là thời gian ước lượng, việc này thì thực ra không gây ra vấn đề gì. Bởi vì trong khoa học máy tính thứ được quan tâm nhiều hơn đối với một thuật toán là thời gian thực thi của nó sẽ tăng nhanh như thế nào khi số lượng phần tử đầu vào thay đổi.\u003c/p\u003e\n\u003cp\u003eTừ đó khái niệm Big-O được ra đời.\u003c/p\u003e\n\u003cp\u003eVà sau đây là một định nghĩa toán học của Big-O\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eCho T(n) và f(n) là hai hàm số dương. Ta viết T(n) = O(f(n)) có nghĩa rằng c . f(n) là cận trên của T(n). Vì vậy tồn tại một hằng số c sao cho T(n) luôn luôn \u0026lt;= c . f(n) với một số n đủ lớn (n \u0026gt;= n0)\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eHay nói một cách dễ hiểu hơn:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eT(n) = O(f(n)) có nghĩa là T(n) không tăng nhanh hơn f(n).\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eLưu ý: Ngoài Big-O, còn có hai khái niệm khác Big Omega(Ω) và Big Thelta(Θ):\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eBig Omega f(n) = Ω(g(n)) có nghĩa là c . g(n) là cận dưới của f(n), có tồn tại một số n \u0026gt;= n0 sao cho f(n) luôn nhỏ hơn c . g(n)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eBig Thelta f(n) = Θ(g(n)) có nghĩa là c1 . g(n) là cận dưới và c2 . g(n) là cận trên của f(n), có tồn tại một số n \u0026gt;= n0 sao cho c1.g(n) \u0026lt;= f(n) \u0026lt;= c2.g(n)\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e2.2.1. Giới thiệu về một số hàm số tăng cơ bản\u003c/h3\u003e\n\u003ch4\u003e2.2.1.1 Hàm số hằng\u003c/h4\u003e\n\u003cp\u003eĐây là trường hợp đơn giản và lý tưởng nhất cho mọi thuật toán T(n) = O(1).\u003c/p\u003e\n\u003cp\u003eTheo như định nghĩa có nghĩa là sẽ tồn tại một giá trị n đủ lớn n \u0026gt;= n0 sao cho T(n) luôn luôn nhỏ hơn một giá trị cố định không phụ thuộc vào n.\u003c/p\u003e\n\u003ch3\u003e2.2.1.2. Hàm số tuyến tính\u003c/h3\u003e\n\u003cp\u003eĐây là trường hợp thuật toán có độ phức tạp theo thời gian T(n) = O(n).\u003c/p\u003e\n\u003cp\u003eÁp dụng định nghĩa của Big-O, điều này có nghĩa là tồn tại một số n đủ lớn n0 sao cho thời gian thực thi của thuật toán luôn nhỏ hơn n\u003c/p\u003e\n\u003ch3\u003e2.2.1.3 Hàm số mũ\u003c/h3\u003e\n\u003cp\u003eĐây là trường hợp thuật toán có độ phức tạp theo thời gian T(n) = O(n2).\u003c/p\u003e\n\u003cp\u003eMột lần nữa áp dụng định nghĩa, điều này có nghĩa là tồn tại một số n đủ lớn sao cho thời gian thực thi của thuật toán luôn nhỏ hơn n2.\u003c/p\u003e\n\u003ch3\u003e2.2.1.4 Ví dụ về thay đổi thời gian thực thi theo đầu vào\u003c/h3\u003e\n\u003cp\u003e\u003cimg src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcQ6MsN%2FbtqubeWgXC4%2FXqPDbr2YJLA03Gx5g9VIJk%2Fimg.jpg\" alt=\"chart\"\u003e\u003c/p\u003e\n\u003ch1\u003eNguồn tham khảo\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://yourbasic.org/\"\u003ehttps://yourbasic.org/\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThe Algorithm Design Manual – Skiena, Steven S.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n","title":"Thuật toán cơ bản: phân tích độ phức tạp giải thuật","date":"2020-10-24"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"basic_algorithm"},"buildId":"qRITv4baP-BSvIAJ11jf9","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"name":"viewport","content":"width=device-width"}],["meta",{"charSet":"utf-8"}],["link",{"rel":"icon","href":"/favicon.ico"}],["meta",{"name":"description","content":"My personal blog"}],["meta",{"property":"og:image","content":"https://og-image.now.sh/Hai%20Sam's%20Blog.png?theme=light\u0026md=0\u0026fontSize=75px\u0026images=https%3A%2F%2Fassets.zeit.co%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"}],["meta",{"name":"og:title","content":"Hai Sam's Blog"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["title",{"children":"Thuật toán cơ bản: phân tích độ phức tạp giải thuật"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-11c8eba6a84e3fddec04.js"></script><script src="/_next/static/chunks/main-d283b4ab393ebd284c3e.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9ec1f7868b3e9d138cdd.js" async=""></script><script src="/_next/static/chunks/commons.e3c12cb767780eaa6561.js" async=""></script><script src="/_next/static/chunks/pages/_app-ded95831299dc0ee3969.js" async=""></script><script src="/_next/static/chunks/7989c093b81d86ddb0abfb342d5bc2e84730435d.a106123a322eba1d4442.js" async=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-f3a8cc6c89a99a8d726d.js" async=""></script><script src="/_next/static/qRITv4baP-BSvIAJ11jf9/_buildManifest.js" async=""></script><script src="/_next/static/qRITv4baP-BSvIAJ11jf9/_ssgManifest.js" async=""></script></body></html>